// The Notices and Disclaimers for Ocean Worlds Autonomy Testbed for Exploration
// Research and Simulation can be found in README.md in the root directory of
// this repository.

// OW power system ROS node - publishes values from a csv generated by the matlab
// battery model as a placeholder for once battery models are linked.


#include <chrono>

#include <ros/ros.h>
#include <ros/package.h>
#include <ros/console.h>
#include <std_msgs/Int16.h>
#include <std_msgs/Float64.h>
#include <fstream>

#include "power_system_util.h"
using namespace std;

float update_count = 0.00; // Timestep initialization
float battery_lifetime = 2738.0; // Estimate of battery lifetime (seconds)
float init_power = 0.00; // Power initialization
float init_temp = 20.00; // Temperature initialization
float init_voltage = 4.10; // Voltage initialization

class SubscribeAndPublish
{
public:
  SubscribeAndPublish()
  {
    //Construct our State of Charge (SOC) publisher
    SOC_pub = nh.advertise<std_msgs::Float64>("power_system_node/state_of_charge",1000);
    //Construct our Remaining Useful Life (RUL) publisher (Seconds)
    RUL_pub = nh.advertise<std_msgs::Int16>("power_system_node/remaining_useful_life",1000);
    //Construct our Battery Temperature (TempBat) publisher
    TempBat_pub = nh.advertise<std_msgs::Float64>("power_system_node/battery_temperature",1000);

    //Construct our Average Mechanical Power subsriber (Watts)
    MechPower_sub = nh.subscribe("/mechanical_power/average", 1000, &SubscribeAndPublish::powerCallback, this);

  }
  void powerCallback(const std_msgs::Float64::ConstPtr& msg)
  {
    using namespace std::chrono;
    ros::NodeHandle nh;

    // Set mechanical power value to rostopic subscription
    float mech_power = msg->data; // [W]

    // Create temperature estimate with pseudorandom noise generator
    float min_temp = 17.5; // minimum temp = 17.5 deg. C
    float max_temp = 21.5; // maximum temp = 21.5 deg. C

    // Temperature estimate based on pseudorandom noise and fixed range
    float temp_est = min_temp + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX/(max_temp - min_temp)));

    // Create voltage estimate with pseudorandom noise generator - needs to decrease over time
    float baseline_voltage = 3.2; // [V] estimate
    float voltage_range = 0.1; // [V] 
    float min_voltage = baseline_voltage + (battery_lifetime - update_count) / battery_lifetime * 0.8; // [V]
    float max_voltage = (baseline_voltage + voltage_range) + (battery_lifetime - update_count) / battery_lifetime * 0.8; // [V]
    
    // If voltage limits dip below baseline, set to baseline values
    if (min_voltage < baseline_voltage)
    {
      min_voltage = baseline_voltage;
    }
    if (max_voltage < (baseline_voltage + voltage_range))
    {
      max_voltage = baseline_voltage + voltage_range;
    }

    // Voltage estimate based on pseudorandom noise and moving range
    float voltage_est = min_voltage + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX/(max_voltage - min_voltage)));
    
    // Create single line csv containing power data and voltage/temp estimates
    string csv_path;
    string default_csv = "/data/gsap_input_data.csv";
    bool csv_path_param_exist = nh.param("power_draw_csv_path", csv_path,
      ros::package::getPath("ow_power_system") + default_csv);

    // Open new file
    std::ofstream myfile;
    myfile.open (csv_path);
    myfile << "Timestamp, power, temperature, voltage\n";
    // First line is used to initialize GSAP at first time step
    myfile << update_count << ", " << init_power << ", " << init_temp << ", " << init_voltage << "\n";
    // Update time step and GSAP initialization parameters
    update_count = update_count + 1.0;
    init_power = mech_power;
    init_temp = temp_est;
    init_voltage = voltage_est;
    // Line used to make the prediction (use current time step)
    myfile << update_count << ", " << mech_power << ", " << temp_est << ", " << voltage_est << "\n";
    myfile.close();

    //individual msgs to be published
    std_msgs::Int16 rul_msg;
    rul_msg.data = 0;  // immediately set to a good default
    std_msgs::Float64 soc_msg;
    soc_msg.data = 0.0;
    std_msgs::Float64 tempbat_msg;
    tempbat_msg.data = 0.0;

    int temp_index = 1; // Set to 1 for now (constant vector). This will change to median SOC or RUL index or fixed percentile

    // Read battery data from newly created file.
    auto power_data = read_file(csv_path);

    // Create a configuration from a file
    string config_path = ros::package::getPath("ow_power_system")+"/config/example.cfg";
    ConfigMap config(config_path);
    // Contruct a new prognoser using the prognoser factory at the first time step. The prognoser
    // will automatically construct an appropriate model, observer and predictor
    // based on the values specified in the config.
    auto prognoser = PrognoserFactory::instance().Create("ModelBasedPrognoser", config);
    // For each line of data in the example file, run a single prediction step.
    for (const auto & line : power_data) {
      // Get a new prediction
      auto prediction = prognoser->step(line);
      // Get the event for battery EoD. The first line of data is used to initialize the observer,
      // so the first prediction won't have any events.
      if (prediction.getEvents().size() == 0) {
        continue;
      }
      auto eod_event = prediction.getEvents().front();
      // The time of event is a `UData` structure, which represents a data
      // point while maintaining uncertainty. For the MonteCarlo predictor
      // used by this example, the uncertainty is captured by storing the
      // result of each particle used in the prediction.
      UData eod_time = eod_event.getTOE();
      if (eod_time.uncertainty() != UType::Samples) {
        // Log warning and don't update the last value
        ROS_WARN_NAMED("power_system_node", "Unexpected uncertainty type for EoD prediction");
      } else { // valid prediction
        
        // Determine the median RUL.
        auto samplesRUL = eod_time.getVec();
        std::sort(samplesRUL.begin(), samplesRUL.end());
        double eod_median = samplesRUL.at(samplesRUL.size() / 2);
        auto now =  MessageClock::now();
        auto now_s = duration_cast<std::chrono::seconds>(now.time_since_epoch());
        double rul_median = eod_median - now_s.count();
        rul_msg.data = rul_median;

        // Determine the median SOC.
        UData currentSOC = eod_event.getState()[0];
        auto samplesSOC = currentSOC.getVec();
        std::sort(samplesSOC.begin(), samplesSOC.end());
        double soc_median = samplesSOC.at(samplesSOC.size() / 2);
        soc_msg.data = soc_median;

        // Determine the Battery Temperature
        auto stateSamples = eod_event.getSystemState()[0];
        std::vector<double> state;
        for (auto sample : stateSamples) {
          state.push_back(sample[0]);
        }
        auto& model = dynamic_cast<ModelBasedPrognoser*>(prognoser.get())->getModel();
        auto z = model.outputEqn(now_s.count(), (PrognosticsModel::state_type) state);
        double temperature = z[temp_index];
        tempbat_msg.data = temperature;
      }
      //publish current SOC, RUL, and battery temperature
      SOC_pub.publish(soc_msg);
      RUL_pub.publish(rul_msg);
      TempBat_pub.publish(tempbat_msg);
    }
  }

private:
  ros::NodeHandle nh;
  ros::Publisher SOC_pub;
  ros::Publisher RUL_pub;
  ros::Publisher TempBat_pub;
  ros::Subscriber MechPower_sub;
};

int main(int argc, char* argv[]) {

  ros::init(argc, argv, "power_system_node");
  SubscribeAndPublish SAPObject;
  ROS_INFO ("Power system node running");
  ros::spin();

  return 0;
}
