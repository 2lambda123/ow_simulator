// The Notices and Disclaimers for Ocean Worlds Autonomy Testbed for Exploration
// Research and Simulation can be found in README.md in the root directory of
// this repository.

// OW power system ROS node - publishes values from a csv generated by the matlab
// battery model as a placeholder for once battery models are linked.


#include <chrono>

#include <ros/ros.h>
#include <ros/package.h>
#include <ros/console.h>
#include <std_msgs/Int16.h>
#include <std_msgs/Float64.h>

#include "power_system_util.h"

using namespace std;

int main(int argc, char* argv[]) {
  using namespace std::chrono;
  ros::init(argc,argv,"power_system_node");
  ros::NodeHandle nh ("power_system_node");

  //Construct our State of Charge (SOC) publisher
  ros::Publisher SOC_pub = nh.advertise<std_msgs::Float64>("state_of_charge",1000);
  //Construct our Remaining Useful Life (RUL) publisher (Seconds)
  ros::Publisher RUL_pub = nh.advertise<std_msgs::Int16>("remaining_useful_life",1000);
  //Construct our Battery Temperature (TempBat) publisher
  ros::Publisher TempBat_pub = nh.advertise<std_msgs::Float64>("battery_temperature",1000);
  
  //Load power values csv
  string csv_path;
  string default_csv = "/data/data_const_load.csv";
  bool csv_path_param_exist = nh.param("power_draw_csv_path", csv_path,
    ros::package::getPath("ow_power_system") + default_csv);

  if (!csv_path_param_exist)
  {
    ROS_WARN_NAMED("power_system_node", "power_draw_csv_path param was not set! Using default value: data_const_load.csv");
  }

  ROS_INFO_STREAM_NAMED("power_system_node", "power_draw_csv_path is set to: " << csv_path);

  // Read battery data from a file.
  auto power_data = read_file(csv_path);

  // Create a configuration from a file
  string config_path = ros::package::getPath("ow_power_system")+"/config/example.cfg";
  ConfigMap config(config_path);
  // Contruct a new prognoser using the prognoser factory. The prognoser
  // will automatically construct an appropriate model, observer and predictor
  // based on the values specified in the config.
  auto prognoser = PrognoserFactory::instance().Create("ModelBasedPrognoser", config);

  // Retrieve our publication rate expressed in Hz
  double power_update_rate = 1;
  double power_update_rate_override;  // allow the user to override it
  bool update_rate_param_exist = nh.param("power_update_rate", power_update_rate_override, 0.1);

  if (update_rate_param_exist)
  {
    ROS_WARN_NAMED("power_system_node", "Overriding the default power_update_rate!");
    // Validated the parameter
    if (power_update_rate == 0)
    {
      ROS_ERROR_NAMED("power_system_node", "power_update_rate param was set to zero! passed value ignored.");
    }
    else
    {
      power_update_rate = power_update_rate_override;
    }
  }

  ROS_INFO_STREAM_NAMED("power_system_node", "power_update_rate is set to: " << power_update_rate << " Hz");
  
  // ROS Loop. Note that once this loop starts,
  // this function (and node) is terminated with an interrupt.
  
  ros::Rate rate(power_update_rate);
  //individual soc_msg to be published by SOC_pub
  std_msgs::Int16 rul_msg;
  rul_msg.data = 0;  // immediately set to a good default
  std_msgs::Float64 soc_msg;
  soc_msg.data = 0.0;
  std_msgs::Float64 tempbat_msg;
  tempbat_msg.data = 0.0;
  ROS_INFO ("Power system node running");

  while (ros::ok()) {

    // For each line of data in the example file, run a single prediction step.
    for (const auto & line : power_data) {
      // Get a new prediction
      auto prediction = prognoser->step(line);
      // Get the event for battery EoD. The first line of data is used to initialize the observer,
      // so the first prediction won't have any events.
      if (prediction.getEvents().size() == 0) {
          continue;
      }
      auto eod_event = prediction.getEvents().front();
      // The time of event is a `UData` structure, which represents a data
      // point while maintaining uncertainty. For the MonteCarlo predictor
      // used by this example, the uncertainty is captured by storing the
      // result of each particle used in the prediction.
      UData eod_time = eod_event.getTOE();
      if (eod_time.uncertainty() != UType::Samples) {
        // Log warning and don't update the last value
        ROS_WARN_NAMED("power_system_node", "Unexpected uncertainty type for EoD prediction");
      } else { // valid prediction
        // For this example, we will print the median EoD.
        auto samplesRUL = eod_time.getVec();
        std::sort(samplesRUL.begin(), samplesRUL.end());
        double eod_median = samplesRUL.at(samplesRUL.size() / 2);
        auto now =  MessageClock::now();
        auto now_s = duration_cast<std::chrono::seconds>(now.time_since_epoch());
        double rul_median = eod_median - now_s.count();
        rul_msg.data = rul_median;

        // State of Charge Code
        UData currentSOC = eod_event.getState()[0];
        // For this example, we will print the median SOC
        auto samplesSOC = currentSOC.getVec();
        std::sort(samplesSOC.begin(), samplesSOC.end());
        double soc_median = samplesSOC.at(samplesSOC.size() / 2);
        soc_msg.data = soc_median;

        // Temperature Code
        auto stateSamples = eod_event.getSystemState()[0];
        std::vector<double> state;
        for (auto sample : stateSamples) {
          state.push_back(sample[0]);
        }
        auto& model = ((ModelBasedPrognoser *) prognoser.get())->getModel();
        auto z = model.outputEqn(now_s.count(), (PrognosticsModel::state_type) state);
        double temperature = z[1];
        tempbat_msg.data = temperature;
      }
      
      //publish current SOC & RUL
      SOC_pub.publish(soc_msg);
      RUL_pub.publish(rul_msg);
      TempBat_pub.publish(tempbat_msg);
      ros::spinOnce();
      rate.sleep();
    }
        
  }
  return 0;
}
