// The Notices and Disclaimers for Ocean Worlds Autonomy Testbed for Exploration
// Research and Simulation can be found in README.md in the root directory of
// this repository.

// OW power system ROS node - publishes values from a csv generated by the matlab
// battery model as a placeholder for once battery models are linked.


#include <chrono>

#include <ros/ros.h>
#include <ros/package.h>
#include <ros/console.h>
#include <std_msgs/Int16.h>
#include <std_msgs/Float64.h>

#include "power_system_node.h"
using namespace std;
using namespace chrono;

double update_count = 0.00; // Timestep initialization
double battery_lifetime = 2738.0; // Estimate of battery lifetime (seconds)
Datum<double> init_power = 0.00; // Power initialization
Datum<double> init_temp = 20.00; // Temperature initialization
Datum<double> init_voltage = 4.10; // Voltage initialization
auto init_time = system_clock::now(); // Timestep initialization

class SubscribeAndPublish
{
public:
  SubscribeAndPublish()
  {
    //Construct our State of Charge (SOC) publisher
    SOC_pub = nh.advertise<std_msgs::Float64>("power_system_node/state_of_charge",1);
    //Construct our Remaining Useful Life (RUL) publisher (Seconds)
    RUL_pub = nh.advertise<std_msgs::Int16>("power_system_node/remaining_useful_life",1);
    //Construct our Battery Temperature (TempBat) publisher
    TempBat_pub = nh.advertise<std_msgs::Float64>("power_system_node/battery_temperature",1);

    //Construct our Average Mechanical Power subsriber (Watts)
    MechPower_sub = nh.subscribe("/mechanical_power/average", 1, &SubscribeAndPublish::powerCallback, this);

  }
  void powerCallback(const std_msgs::Float64::ConstPtr& msg)
  {
    using namespace std::chrono;
    ros::NodeHandle nh;

    // Set mechanical power value to rostopic subscription
    double mech_power = msg->data; // [W]

    // Create temperature estimate with pseudorandom noise generator
    double min_temp = 17.5; // minimum temp = 17.5 deg. C
    double max_temp = 21.5; // maximum temp = 21.5 deg. C

    // Temperature estimate based on pseudorandom noise and fixed range
    double temp_est = min_temp + static_cast <double> (rand()) / RAND_MAX * (max_temp - min_temp);

    // Create voltage estimate with pseudorandom noise generator - needs to decrease over time
    double baseline_voltage = 3.2; // [V] estimate
    double voltage_range = 0.1; // [V] 
    double min_voltage = baseline_voltage + (battery_lifetime - update_count) / battery_lifetime * 0.8; // [V]
    double max_voltage = (baseline_voltage + voltage_range) + (battery_lifetime - update_count) / battery_lifetime * 0.8; // [V]
    
    // If voltage limits dip below baseline, set to baseline values
    if (min_voltage < baseline_voltage)
    {
      min_voltage = baseline_voltage;
    }
    if (max_voltage < (baseline_voltage + voltage_range))
    {
      max_voltage = baseline_voltage + voltage_range;
    }

    // Voltage estimate based on pseudorandom noise and moving range
    double voltage_est = min_voltage + static_cast <double> (rand()) / RAND_MAX * (max_voltage - min_voltage);

    //individual msgs to be published
    std_msgs::Int16 rul_msg;
    rul_msg.data = 0;  // immediately set to a good default
    std_msgs::Float64 soc_msg;
    soc_msg.data = 0.0;
    std_msgs::Float64 tempbat_msg;
    tempbat_msg.data = 0.0;

    int temp_index = 1; // Set to 1 for now (constant vector). This will change to median SOC or RUL index or fixed percentile

    vector<map<MessageId, Datum<double>>> power_data; // GSAP Input Vector Definition
    map<MessageId, Datum<double>> initialization_data; // GSAP Initialization Data
    map<MessageId, Datum<double>> current_data; // GSAP Input Data at Current Timestep

    // Set timestamp for initialization data to initialization time
    init_power.setTime(init_time);
    init_temp.setTime(init_time);
    init_voltage.setTime(init_time);

    // Determine timestamp for current callback
    auto timestamp = system_clock::now();
    
    // Assign input parameters and corresponding timestamp
    Datum<double> power = mech_power;
    power.setTime(timestamp);
    Datum<double> temperature = temp_est;
    temperature.setTime(timestamp);
    Datum<double> voltage = voltage_est;
    voltage.setTime(timestamp);

    // Populate initialization data structure
    initialization_data.insert({MessageId::Watts, init_power});
    initialization_data.insert({MessageId::Centigrade, init_temp});
    initialization_data.insert({MessageId::Volts, init_voltage});
    power_data.push_back(initialization_data);

    // Populate current timestep data structure
    current_data.insert({MessageId::Watts, power});
    current_data.insert({MessageId::Centigrade, temperature});
    current_data.insert({MessageId::Volts, voltage});
    power_data.push_back(current_data);

    // Update count and GSAP initialization parameters
    update_count = update_count + 1.0;
    init_power = mech_power;
    init_temp = temp_est;
    init_voltage = voltage_est;
    init_time = timestamp;

    // Create a configuration from a file
    string config_path = ros::package::getPath("ow_power_system")+"/config/example.cfg";
    ConfigMap config(config_path);
    // Contruct a new prognoser using the prognoser factory. The prognoser
    // will automatically construct an appropriate model, observer and predictor
    // based on the values specified in the config.
    auto prognoser = PrognoserFactory::instance().Create("ModelBasedPrognoser", config);
    // For each line of data in the example file, run a single prediction step.
    for (const auto & line : power_data) {
      // Get a new prediction
      auto prediction = prognoser->step(line);
      // Get the event for battery EoD. The first line of data is used to initialize the observer,
      // so the first prediction won't have any events.
      if (prediction.getEvents().size() == 0) {
        continue;
      }
      auto eod_event = prediction.getEvents().front();
      // The time of event is a `UData` structure, which represents a data
      // point while maintaining uncertainty. For the MonteCarlo predictor
      // used by this example, the uncertainty is captured by storing the
      // result of each particle used in the prediction.
      UData eod_time = eod_event.getTOE();
      if (eod_time.uncertainty() != UType::Samples) {
        // Log warning and don't update the last value
        ROS_WARN_NAMED("power_system_node", "Unexpected uncertainty type for EoD prediction");
      } else { // valid prediction
        
        // Determine the median RUL.
        auto samplesRUL = eod_time.getVec();
        std::sort(samplesRUL.begin(), samplesRUL.end());
        double eod_median = samplesRUL.at(samplesRUL.size() / 2);
        auto now =  MessageClock::now();
        auto now_s = duration_cast<std::chrono::seconds>(now.time_since_epoch());
        double rul_median = eod_median - now_s.count();
        rul_msg.data = rul_median;

        // Determine the median SOC.
        UData currentSOC = eod_event.getState()[0];
        auto samplesSOC = currentSOC.getVec();
        std::sort(samplesSOC.begin(), samplesSOC.end());
        double soc_median = samplesSOC.at(samplesSOC.size() / 2);
        soc_msg.data = soc_median;

        // Determine the Battery Temperature
        auto stateSamples = eod_event.getSystemState()[0];
        std::vector<double> state;
        for (auto sample : stateSamples) {
          state.push_back(sample[0]);
        }
        auto& model = dynamic_cast<ModelBasedPrognoser*>(prognoser.get())->getModel();
        auto z = model.outputEqn(now_s.count(), (PrognosticsModel::state_type) state);
        double batt_temperature = z[temp_index];
        tempbat_msg.data = batt_temperature;
      }
      //publish current SOC, RUL, and battery temperature
      SOC_pub.publish(soc_msg);
      RUL_pub.publish(rul_msg);
      TempBat_pub.publish(tempbat_msg);
    }
  }

private:
  ros::NodeHandle nh;
  ros::Publisher SOC_pub;
  ros::Publisher RUL_pub;
  ros::Publisher TempBat_pub;
  ros::Subscriber MechPower_sub;
};

int main(int argc, char* argv[]) {

  ros::init(argc, argv, "power_system_node");
  SubscribeAndPublish SAPObject;
  ROS_INFO ("Power system node running");
  ros::spin();

  return 0;
}
